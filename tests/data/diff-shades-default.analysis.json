{
  "projects": {
    "diff-shades": {
      "name": "diff-shades",
      "url": "https://github.com/ichard26/diff-shades.git",
      "custom_arguments": [],
      "python_requires": null,
      "commit": "27dae55718ef859c66dd2f1c12009972570a7eb9"
    }
  },
  "results": {
    "diff-shades": {
      "diff_shades/__init__.py": {
        "type": "nothing-changed",
        "src": "\"\"\"\nThe Black shade analyser and comparison tool.\n\"\"\"\n\n__author__ = \"Richard Si, et al.\"\n__license__ = \"MIT\"\n__version__ = \"21.10a1\"\n",
        "line_count": 7
      },
      "diff_shades/__main__.py": {
        "type": "nothing-changed",
        "src": "from diff_shades.cli import main\n\nmain()\n",
        "line_count": 3
      },
      "diff_shades/analysis.py": {
        "type": "nothing-changed",
        "src": "# ================================\n# > Formatting results collection\n# =============================\n\nimport dataclasses\nimport multiprocessing\nimport shutil\nimport subprocess\nimport sys\nimport time\nfrom dataclasses import field, replace\nfrom functools import partial\nfrom pathlib import Path\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Dict,\n    Iterator,\n    List,\n    Optional,\n    Tuple,\n    Union,\n    overload,\n)\nfrom unittest.mock import patch\n\nif sys.version_info >= (3, 8):\n    from typing import Final, Literal\nelse:\n    from typing_extensions import Final, Literal\n\nif TYPE_CHECKING:\n    import black\n\nimport rich\nimport rich.progress\n\nfrom diff_shades.config import Project\nfrom diff_shades.output import suppress_output\n\nGIT_BIN: Final = shutil.which(\"git\")\nFILE_RESULT_COLORS: Final = {\n    \"reformatted\": \"cyan\",\n    \"nothing-changed\": \"magenta\",\n    \"failed\": \"red\",\n}\nrun_cmd: Final = partial(\n    subprocess.run,\n    check=True,\n    encoding=\"utf8\",\n    stdout=subprocess.PIPE,\n    stderr=subprocess.STDOUT,\n)\nconsole: Final = rich.get_console()\n\n# ============================================\n# > Analysis data representation & processing\n# ==========================================\n\nJSON = Any\nResultTypes = Literal[\"nothing-changed\", \"reformatted\", \"failed\"]\n\n\n@dataclasses.dataclass(frozen=True, init=False)\nclass FileResult:\n    type: ResultTypes\n    src: str\n\n\n@dataclasses.dataclass(frozen=True)\nclass NothingChangedResult(FileResult):\n    type: Literal[\"nothing-changed\"] = field(default=\"nothing-changed\", init=False)\n\n\n@dataclasses.dataclass(frozen=True)\nclass ReformattedResult(FileResult):\n    type: Literal[\"reformatted\"] = field(default=\"reformatted\", init=False)\n    dst: str\n\n\n@dataclasses.dataclass(frozen=True)\nclass FailedResult(FileResult):\n    type: Literal[\"failed\"] = field(default=\"failed\", init=False)\n    error: str\n    message: str\n\n\n@dataclasses.dataclass\nclass ProjectData:\n    results: Dict[str, FileResult]\n    project: Project\n\n\n@dataclasses.dataclass\nclass AnalysisData:\n    projects: Dict[str, ProjectData]\n    metadata: Dict[str, Any] = dataclasses.field(default_factory=dict)\n\n    @classmethod\n    def load(cls, data: JSON) -> \"AnalysisData\":\n        projects = {}\n        for name, project_data in data[\"projects\"].items():\n            files: Dict[str, FileResult] = {}\n            for filepath, result in project_data[\"results\"].items():\n                if result[\"type\"] == \"reformatted\":\n                    files[filepath] = ReformattedResult(\n                        src=result[\"src\"], dst=result[\"dst\"]\n                    )\n                elif result[\"type\"] == \"nothing-changed\":\n                    files[filepath] = NothingChangedResult(src=result[\"src\"])\n                elif result[\"type\"] == \"failed\":\n                    files[filepath] = FailedResult(\n                        src=result[\"src\"],\n                        error=result[\"error\"],\n                        message=result[\"message\"],\n                    )\n            project_definition = Project(**project_data[\"project\"])\n            projects[name] = ProjectData(results=files, project=project_definition)\n\n        return cls(projects=projects, metadata=data[\"metadata\"])\n\n    def __iter__(self) -> Iterator[ProjectData]:\n        return iter(self.projects.values())\n\n    @property\n    def files(self) -> List[FileResult]:\n        files: List[FileResult] = []\n        for proj_data in self.projects.values():\n            files.extend(proj_data.results.values())\n        return files\n\n\n@overload\ndef filter_results(\n    file_results: Dict[str, FileResult], type: str\n) -> Dict[str, FileResult]:\n    ...\n\n\n@overload\ndef filter_results(file_results: List[FileResult], type: str) -> List[FileResult]:\n    ...\n\n\ndef filter_results(\n    file_results: Union[Dict[str, FileResult], List[FileResult]], type: str\n) -> Union[Dict[str, FileResult], List[FileResult]]:\n    if isinstance(file_results, list):\n        return [result for result in file_results if result.type == type]\n    else:\n        return {\n            file: result for file, result in file_results.items() if result.type == type\n        }\n\n\n# =====================\n# > Setup and analysis\n# ==================\n\n\ndef clone_repo(url: str, *, to: Path, sha: Optional[str] = None) -> None:\n    assert GIT_BIN\n    if sha:\n        if not to.exists():\n            to.mkdir()\n        run_cmd([\"git\", \"init\"], cwd=to)\n        run_cmd([\"git\", \"fetch\", url, sha], cwd=to)\n        run_cmd([\"git\", \"checkout\", sha], cwd=to)\n    else:\n        run_cmd([GIT_BIN, \"clone\", url, \"--depth\", \"1\", str(to)])\n\n\nCommitMsg = str\nCommitSHA = str\n\n\ndef get_commit(repo: Path) -> Tuple[CommitSHA, CommitMsg]:\n    assert GIT_BIN\n    proc = run_cmd([GIT_BIN, \"log\", \"--format=%H:%s\", \"-n1\"], cwd=repo)\n    output = proc.stdout.strip()\n    sha, _, msg = output.partition(\":\")\n    return sha, msg\n\n\ndef setup_projects(\n    projects: List[Project],\n    workdir: Path,\n    progress: rich.progress.Progress,\n    task: rich.progress.TaskID,\n    verbose: bool,\n) -> List[Tuple[Project, Path]]:\n    ready = []\n    for proj in projects:\n        target = Path(workdir, proj.name)\n        can_reuse = False\n        if target.exists():\n            if proj.commit is None:\n                can_reuse = True\n            else:\n                sha, _ = get_commit(target)\n                can_reuse = proj.commit == sha\n\n        if can_reuse:\n            progress.console.log(\n                f\"[bold]Using pre-existing clone of {proj.name}[/] \\[{proj.url}]\"\n            )\n        else:\n            clone_repo(proj.url, to=target, sha=proj.commit)\n            progress.console.log(f\"[bold]Cloned {proj.name}[/] \\[{proj.url}]\")\n\n        commit_sha, commit_msg = get_commit(target)\n        if verbose:\n            progress.console.log(f\"[dim]  commit -> {commit_msg}\", highlight=False)\n            progress.console.log(f\"[dim]  commit -> {commit_sha}\")\n        proj = replace(proj, commit=commit_sha)\n        ready.append((proj, target))\n        progress.advance(task)\n\n    return ready\n\n\n# HACK: I know this is hacky but the benefit is I don't need to copy and\n# paste a bunch of black's argument parsing, file discovery, and\n# configuration code. I also get to keep the pretty output since I can\n# directly invoke black.format_file_contents :D\n\n\ndef get_project_files_and_mode(\n    project: Project, path: Path\n) -> Tuple[List[Path], \"black.FileMode\"]:\n    import black\n\n    files: List[Path] = []\n    mode = None\n\n    def shim(sources: List[Path], *args: Any, **kwargs: Any) -> None:\n        nonlocal files, mode\n        files.extend(sources)\n        mode = kwargs[\"mode\"]\n\n    with suppress_output(), patch(\"black.reformat_many\", new=shim):\n        black.main(\n            [str(path), *project.custom_arguments, \"--check\"], standalone_mode=False\n        )\n\n    assert files and isinstance(mode, black.FileMode)\n    return sorted(p for p in files if p.suffix in (\".py\", \".pyi\")), mode\n\n\ndef check_file(path: Path, *, mode: Optional[\"black.FileMode\"] = None) -> FileResult:\n    import black\n\n    # TODO: record log files if available\n    # TODO: allow more control w/ black.Mode so we could use diff-shades to compare\n    # for example, no-ESP vs ESP.\n\n    mode = mode or black.FileMode()\n    if path.suffix == \".pyi\":\n        mode = replace(mode, is_pyi=True)\n\n    src = path.read_text(\"utf8\")\n    try:\n        dst = black.format_file_contents(src, fast=False, mode=mode)\n    except black.NothingChanged:\n        return NothingChangedResult(src=src)\n\n    except Exception as err:\n        return FailedResult(src=src, error=err.__class__.__name__, message=str(err))\n\n    return ReformattedResult(src=src, dst=dst)\n\n\ndef check_file_shim(\n    # Unfortunately there's nothing like imap + starmap in multiprocessing.\n    arguments: Tuple[Path, Path, \"black.FileMode\"]\n) -> Tuple[str, FileResult]:\n    file, project_path, mode = arguments\n    result = check_file(file, mode=mode)\n    normalized_path = file.relative_to(project_path).as_posix()\n    return (normalized_path, result)\n\n\ndef analyze_projects(\n    projects: List[Tuple[Project, Path]],\n    progress: rich.progress.Progress,\n    task: rich.progress.TaskID,\n    verbose: bool,\n) -> Dict[str, ProjectData]:\n    # TODO: refactor this and related functions cuz it's a bit of a mess :)\n    files_and_modes = [get_project_files_and_mode(proj, path) for proj, path in projects]\n    file_count = sum(len(files) for files, _ in files_and_modes)\n    progress.update(task, total=file_count)\n\n    def check_project_files(\n        files: List[Path], project_path: Path, *, mode: \"black.FileMode\"\n    ) -> Dict[str, FileResult]:\n        file_results = {}\n        data_packets = [(file_path, project_path, mode) for file_path in files]\n        for (filepath, result) in pool.imap(check_file_shim, data_packets):\n            if verbose:\n                result_colour = FILE_RESULT_COLORS[result.type]\n                console.log(f\"  {filepath}: [{result_colour}]{result.type}\")\n            file_results[filepath] = result\n            progress.advance(task)\n            progress.advance(project_task)\n        return file_results\n\n    with multiprocessing.Pool() as pool:\n        results = {}\n        for (project, path), (files, mode) in zip(projects, files_and_modes):\n            project_task = progress.add_task(\n                f\"[bold] on {project.name}\", total=len(files)\n            )\n            if verbose:\n                console.log(f\"[bold]Checking {project.name}[/] ({len(files)} files)\")\n            t0 = time.perf_counter()\n            file_results = check_project_files(files, path, mode=mode)\n            results[project.name] = ProjectData(results=file_results, project=project)\n            elapsed = time.perf_counter() - t0\n            console.log(f\"[bold]{project.name} finished[/] (in {elapsed:.3f} seconds)\")\n            progress.remove_task(project_task)\n\n    return results\n",
        "line_count": 323
      },
      "diff_shades/cli.py": {
        "type": "nothing-changed",
        "src": "# =============================\n# > Command implementations\n# ============================\n\nimport contextlib\nimport dataclasses\nimport json\nimport sys\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom tempfile import TemporaryDirectory\nfrom typing import ContextManager, Iterator, List, Optional, TypeVar\n\nimport click\nimport rich\nimport rich.traceback\nfrom rich.panel import Panel\nfrom rich.table import Table\n\nimport diff_shades\nfrom diff_shades.analysis import (\n    FILE_RESULT_COLORS,\n    GIT_BIN,\n    AnalysisData,\n    analyze_projects,\n    filter_results,\n    setup_projects,\n)\nfrom diff_shades.config import PROJECTS\nfrom diff_shades.output import make_rich_progress\n\nconsole = rich.get_console()\n\nT = TypeVar(\"T\")\n\n\n@contextlib.contextmanager\ndef nullcontext(enter_result: T) -> Iterator[T]:\n    # contextlib.nullcontext was only added in 3.7+\n    yield enter_result\n\n\n@click.group()\n@click.option(\"--force-color\", is_flag=True, help=\"Force colored output.\")\n@click.version_option(version=diff_shades.__version__, prog_name=\"diff-shades\")\ndef main(force_color: bool) -> None:\n    \"\"\"\n    The Black shade analyser and comparison tool.\n\n    AKA Richard's personal take at a better black-primer (by stealing\n    ideas from mypy-primer) :p\n\n    Basically runs Black over millions of lines of code from various\n    open source projects. Why? So any changes to Black can be gauged\n    on their relative impact.\n\n    \\b\n    Features include:\n     - Simple but readable diffing capabilities\n     - Repeatable analyses via --repeat-projects-from\n     - Per-project python_requires support\n     - Structured JSON output\n     - Oh and of course, very pretty output!\n\n    \\b\n    Potential tasks / additionals:\n     - jupyter notebook support\n     - even more helpful output\n     - stronger diffing abilities\n     - better UX (particularly when things go wrong)\n     - so much code cleanup - like a lot :p\n    \"\"\"\n    rich.traceback.install(suppress=[click], show_locals=True)\n    rich.reconfigure(log_path=False)\n    if force_color:\n        rich.reconfigure(log_path=False, color_system=\"truecolor\")\n\n\n# fmt: off\n@main.command()\n@click.argument(\n    \"results-filepath\", metavar=\"results-filepath\",\n    type=click.Path(resolve_path=True, readable=False, writable=True, path_type=Path)\n)\n@click.option(\n    \"-s\", \"--select\",\n    multiple=True,\n    help=\"Select projects from the main list.\"\n)\n@click.option(\n    \"-e\", \"--exclude\",\n    multiple=True,\n    help=\"Exclude projects from running.\"\n)\n@click.option(\n    \"-w\", \"--work-dir\",\n    type=click.Path(exists=False, dir_okay=True, file_okay=False, resolve_path=True, path_type=Path),\n    help=(\n        \"Directory where project clones are used / stored. By default a\"\n        \" temporary directory is used which will be cleaned up at exit.\"\n        \" Use this option to reuse or cache projects.\"\n    )\n)\n@click.option(\n    \"--repeat-projects-from\",\n    type=click.Path(exists=True, dir_okay=False, file_okay=True, resolve_path=True, path_type=Path),\n    help=(\n        \"Use the same projects (and commits!) used during another anaylsis.\"\n        \" This is similar to --work-dir but for when you don't have the\"\n        \" checkouts available.\"\n    )\n)\n@click.option(\n    \"-v\", \"--verbose\",\n    is_flag=True,\n    help=\"Be more verbose.\"\n)\n# fmt: on\ndef analyze(\n    results_filepath: Path,\n    select: List[str],\n    exclude: List[str],\n    work_dir: Optional[Path],\n    repeat_projects_from: Optional[Path],\n    verbose: bool,\n) -> None:\n    \"\"\"Run Black against 'millions' of LOC and save the results.\"\"\"\n\n    try:\n        import black\n    except ImportError as err:\n        console.print(f\"[red bold]Couldn't import black: {err}\")\n        console.print(\"[bold]-> This command requires an installation of Black.\")\n        sys.exit(1)\n\n    if GIT_BIN is None:\n        console.print(\"[red bold]Couldn't find a Git executable.\")\n        console.print(\"[bold]-> This command requires git sadly enough.\")\n        sys.exit(1)\n\n    if repeat_projects_from:\n        data = json.loads(repeat_projects_from.read_text(\"utf-8\"))\n        projects = [proj_data.project for proj_data in AnalysisData.load(data)]\n    else:\n        projects = PROJECTS\n\n    if exclude:\n        excluders = [e.casefold().strip() for e in exclude]\n        projects = [p for p in projects if p.name not in excluders]\n    if select:\n        selectors = [project.casefold().strip() for project in select]\n        projects = [p for p in projects if p.name in selectors]\n    filtered = []\n    for proj in projects:\n        if proj.supported_by_runtime:\n            filtered.append(proj)\n        else:\n            console.log(\n                f\"[bold yellow]Skipping {proj.name} as it requires python{proj.python_requires}\"\n            )\n\n    workdir_provider: ContextManager\n    if work_dir:\n        workdir_provider = nullcontext(work_dir)\n        if not work_dir.exists():\n            work_dir.mkdir()\n    else:\n        workdir_provider = TemporaryDirectory(prefix=\"diff-shades-\")\n\n    with workdir_provider as _work_dir:\n        with make_rich_progress() as progress:\n            setup_task = progress.add_task(\n                \"[bold blue]Setting up projects\", total=len(projects)\n            )\n            prepped_projects = setup_projects(\n                filtered, Path(_work_dir), progress, setup_task, verbose\n            )\n        if not console.is_terminal:\n            # Curiously this is needed when redirecting to a file so the next emitted\n            # line isn't attached to the (completed) progress bar.\n            console.line()\n\n        with make_rich_progress() as progress:\n            analyze_task = progress.add_task(\"[bold magenta]Running black\")\n            results = analyze_projects(prepped_projects, progress, analyze_task, verbose)\n        metadata = {\n            \"black_version\": black.__version__,\n            \"created_at\": datetime.now(timezone.utc).isoformat(),\n        }\n        analysis = AnalysisData(projects=results, metadata=metadata)\n        if not console.is_terminal:\n            # Curiously this is needed when redirecting to a file so the next emitted\n            # line isn't attached to the (completed) progress bar.\n            console.line()\n\n    with open(results_filepath, \"w\", encoding=\"utf-8\") as f:\n        raw = dataclasses.asdict(analysis)\n        json.dump(raw, f, separators=(\",\", \":\"), ensure_ascii=False)\n        f.write(\"\\n\")\n\n    console.line()\n    main_table = Table.grid()\n    file_table = Table(title=\"File breakdown\", show_edge=False, box=rich.box.SIMPLE)\n    file_table.add_column(\"Result\")\n    file_table.add_column(\"# of files\")\n    for type in (\"nothing-changed\", \"reformatted\", \"failed\"):\n        count = len(filter_results(analysis.files, type))\n        file_table.add_row(type, str(count), style=FILE_RESULT_COLORS[type])\n    project_table = Table(title=\"Project breakdown\", show_edge=False, box=rich.box.SIMPLE)\n    project_table.add_column(\"Result\")\n    project_table.add_column(\"# of projects\")\n    for type in (\"nothing-changed\", \"reformatted\", \"failed\"):\n        if type == \"nothing-changed\":\n            count = sum(\n                proj.results == filter_results(proj.results, type) for proj in analysis\n            )\n        else:\n            count = sum(bool(filter_results(proj.results, type)) for proj in analysis)\n        project_table.add_row(type, str(count), style=FILE_RESULT_COLORS[type])\n    main_table.add_row(file_table, \"   \", project_table)\n    main_table.add_row(\n        f\"\\n[bold]# of files: {len(analysis.files)}\\n\"\n        f\"[bold]# of projects: {len(analysis.projects)}\"\n    )\n    panel = Panel(main_table, title=\"[bold]Summary\", expand=False)\n    console.print(panel)\n\n\n@main.command()\n@click.argument(\n    \"analysis-one\",\n    metavar=\"analysis-one\",\n    type=click.Path(resolve_path=True, exists=True, readable=True, path_type=Path),\n)\n@click.argument(\n    \"analysis-two\",\n    metavar=\"analysis-two\",\n    type=click.Path(resolve_path=True, exists=True, readable=True, path_type=Path),\n)\n@click.option(\n    \"--check\", is_flag=True, help=\"Return a non-zero exit code if differences were found.\"\n)\ndef compare(analysis_one: Path, analysis_two: Path, check: bool) -> None:\n    \"\"\"Compare two analyses for differences in the results.\"\"\"\n\n    # TODO: allow filtering of projects and files checked\n    # TODO: more informative output (in particular on the differences)\n\n    first = AnalysisData.load(json.loads(analysis_one.read_text(\"utf-8\")))\n    console.log(f\"Loaded first analysis: {analysis_one}\")\n    second = AnalysisData.load(json.loads(analysis_two.read_text(\"utf-8\")))\n    console.log(f\"Loaded second analysis: {analysis_two}\")\n\n    # TODO: Gracefully warn but accept analyses that weren't set up the exact same way.\n    # fmt: off\n    if (\n        set(first.projects) ^ set(second.projects)\n        or not all(x.project == y.project for x, y in zip(first, second))\n    ):\n    # fmt: on\n        console.print(\"[bold red]\\nThe two analyses don't have the same set of projects.\")\n        console.print(\n            \"[italic]-> Eventually this will be just a warning, but that's a TODO\"\n        )\n        sys.exit(1)\n\n    console.line()\n    if first == second:\n        console.print(f\"[bold {FILE_RESULT_COLORS['nothing-changed']}]Nothing-changed.\")\n        sys.exit(0)\n    else:\n        console.print(f\"[bold {FILE_RESULT_COLORS['reformatted']}]Differences found.\")\n        sys.exit(1 if check else 0)\n",
        "line_count": 273
      },
      "diff_shades/config.py": {
        "type": "nothing-changed",
        "src": "# ============================\n# > Project definition & setup\n# ============================\n\nimport dataclasses\nimport platform\nimport sys\nfrom typing import List, Optional\n\nif sys.version_info >= (3, 8):\n    from typing import Final\nelse:\n    from typing_extensions import Final\n\nfrom packaging.specifiers import SpecifierSet\n\n\n@dataclasses.dataclass(eq=True)\nclass Project:\n    name: str\n    url: str\n    custom_arguments: List[str] = dataclasses.field(default_factory=list)\n    python_requires: Optional[str] = None\n    commit: Optional[str] = None\n\n    @property\n    def supported_by_runtime(self) -> bool:\n        if self.python_requires is None:\n            return True\n\n        return SpecifierSet(self.python_requires).contains(platform.python_version())\n\n\nPROJECTS: Final = [\n    Project(\"aioexabgp\", \"https://github.com/cooperlees/aioexabgp.git\"),\n    Project(\"attrs\", \"https://github.com/python-attrs/attrs.git\"),\n    Project(\"bandersnatch\", \"https://github.com/pypa/bandersnatch.git\"),\n    Project(\"black\", \"https://github.com/psf/black.git\"),\n    Project(\"blackbench\", \"https://github.com/ichard26/blackbench.git\"),\n    Project(\"channel\", \"https://github.com/django/channels.git\"),\n    Project(\n        \"django\",\n        \"https://github.com/django/django.git\",\n        custom_arguments=[\n            \"--skip-string-normalization\",\n            \"--extend-exclude\",\n            (\n                \"/((docs|scripts)/|django/forms/models.py\"\n                \"|tests/gis_tests/test_spatialrefsys.py\"\n                \"|tests/test_runner_apps/tagged/tests_syntax_error.py)\"\n            ),\n        ],\n        python_requires=\">=3.8\",\n    ),\n    Project(\"flake8-bugbear\", \"https://github.com/PyCQA/flake8-bugbear.git\"),\n    Project(\"hypothesis\", \"https://github.com/HypothesisWorks/hypothesis.git\"),\n    Project(\"pandas\", \"https://github.com/pandas-dev/pandas.git\"),\n    Project(\"pillow\", \"https://github.com/python-pillow/Pillow.git\"),\n    Project(\"poetry\", \"https://github.com/python-poetry/poetry.git\"),\n    Project(\"pyanalyze\", \"https://github.com/quora/pyanalyze.git\"),\n    Project(\"pyramid\", \"https://github.com/Pylons/pyramid.git\"),\n    Project(\"ptr\", \"https://github.com/facebookincubator/ptr.git\"),\n    Project(\"pytest\", \"https://github.com/pytest-dev/pytest.git\"),\n    Project(\"scikit-lego\", \"https://github.com/koaning/scikit-lego\"),\n    Project(\"sqlalchemy\", \"https://github.com/sqlalchemy/sqlalchemy.git\"),\n    Project(\"tox\", \"https://github.com/tox-dev/tox.git\"),\n    Project(\"typeshed\", \"https://github.com/python/typeshed.git\"),\n    Project(\"virtualenv\", \"https://github.com/pypa/virtualenv.git\"),\n    Project(\"warehouse\", \"https://github.com/pypa/warehouse.git\"),\n]\nfor p in PROJECTS:\n    if p.custom_arguments is None:\n        p.custom_arguments = [\"--experimental-string-processing\"]\n    else:\n        p.custom_arguments.append(\"--experimental-string-processing\")\n",
        "line_count": 75
      },
      "diff_shades/output.py": {
        "type": "nothing-changed",
        "src": "# ====================================\n# > Messaging and reporting utilities\n# =================================\n\nimport contextlib\nimport difflib\nimport os\nfrom contextlib import redirect_stderr, redirect_stdout\nfrom typing import Iterator\n\nimport rich\nimport rich.progress\n\nconsole = rich.get_console()\n\n# NOTE: These two functions were copied straight from black.output :P\n\n\ndef unified_diff(a: str, b: str, a_name: str, b_name: str) -> str:\n    \"\"\"Return a unified diff string between strings `a` and `b`.\"\"\"\n    a_lines = [line for line in a.splitlines(keepends=True)]\n    b_lines = [line for line in b.splitlines(keepends=True)]\n    diff_lines = []\n    for line in difflib.unified_diff(\n        a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5\n    ):\n        # Work around https://bugs.python.org/issue2142. See also:\n        # https://www.gnu.org/software/diffutils/manual/html_node/Incomplete-Lines.html\n        if line[-1] == \"\\n\":\n            diff_lines.append(line)\n        else:\n            diff_lines.append(line + \"\\n\")\n            diff_lines.append(\"\\\\ No newline at end of file\\n\")\n    return \"\".join(diff_lines)\n\n\ndef colour_diff(contents: str) -> str:\n    \"\"\"Inject ANSI colour codes to the diff.\"\"\"\n    lines = contents.split(\"\\n\")\n    for i, line in enumerate(lines):\n        if line.startswith(\"+++\") or line.startswith(\"---\"):\n            line = \"\\033[1;37m\" + line + \"\\033[0m\"  # bold white, reset\n        elif line.startswith(\"@@\"):\n            line = \"\\033[36m\" + line + \"\\033[0m\"  # cyan, reset\n        elif line.startswith(\"+\"):\n            line = \"\\033[32m\" + line + \"\\033[0m\"  # green, reset\n        elif line.startswith(\"-\"):\n            line = \"\\033[31m\" + line + \"\\033[0m\"  # red, reset\n        lines[i] = line\n    return \"\\n\".join(lines)\n\n\n@contextlib.contextmanager\ndef suppress_output() -> Iterator:\n    with open(os.devnull, \"w\", encoding=\"utf-8\") as blackhole:\n        with redirect_stdout(blackhole), redirect_stderr(blackhole):\n            yield\n\n\ndef make_rich_progress() -> rich.progress.Progress:\n    return rich.progress.Progress(\n        \"[progress.description]{task.description}\",\n        rich.progress.BarColumn(),\n        \"[progress.percentage]{task.percentage:>3.0f}%\",\n        \"-\",\n        \"[progress.percentage]{task.completed}/{task.total}\",\n        \"-\",\n        rich.progress.TimeElapsedColumn(),\n        console=console,\n    )\n",
        "line_count": 70
      },
      "noxfile.py": {
        "type": "nothing-changed",
        "src": "from pathlib import Path\n\nimport nox\n\nSUPPORTED_PYTHONS = [\"3.6\", \"3.7\", \"3.8\", \"3.9\", \"3.10\"]\n\nnox.needs_version = \">=2021.10.1\"\nnox.options.error_on_external_run = True\n\n\n@nox.session(python=SUPPORTED_PYTHONS)\ndef tests(session: nox.Session) -> None:\n    session.install(\".\")\n    session.run(\"diff-shades\", \"--version\")\n    session.install(\"black\")\n    target = Path(session.create_tmp(), \"fake-devnull\")\n    cache = Path(session.create_tmp(), \"cache\")\n    base = [\"diff-shades\", \"--force-color\", \"analyze\", str(target)]\n    session.run(*base, \"-s\", \"blackbench\", \"-w\", str(cache))\n    session.run(*base, \"-s\", \"blackbench\", \"-s\", \"black\", \"-w\", str(cache))\n",
        "line_count": 20
      }
    }
  },
  "metadata": {
    "black-version": "21.12b0",
    "black-extra-args": [],
    "created-at": "2022-01-03T20:40:08.703857+00:00",
    "data-format": 1.1
  }
}
